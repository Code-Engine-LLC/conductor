require 'rails_helper'

RSpec.describe MessageCreator do
  let(:sample_shard_value) { rand(1..1024) }
  let(:request) do
    ActionDispatch::Request.new(Rack::MockRequest.env_for("http://example.com:8080/", {"HTTP_SAMPLE_SHARD_ID" => sample_shard_value, "REMOTE_ADDR" => "10.10.10.10"}))
  end

  let(:settings) do
    {}
  end

  let(:http_headers) do
    {}
  end

  let(:body) do
    ""
  end

  let(:options) do
    {
      settings: settings,
      headers: http_headers,
      body: body
    }
  end

  subject(:provider) { ShardIdProvider.new options }

  describe "#shard_id" do
    context "no extracted shard" do
      it "returns nil when there is no shard" do
        expect(subject.shard_id).to be nil
      end
    end

    context "shard header provided" do
      let(:settings) do
        {
          shard_tag: 'Sample-Shard-Id'
        }
      end

      let(:http_headers) do
        {
          'Sample-shard-id' => 5
        }
      end

      it "returns shard from header" do
        expect(subject.shard_id).to eq 5
      end
    end

    context "autogenerated shard" do
      let(:options) do
        {
          settings: {
            search_text_number_characters: 10,
            search_text_words: 'vin',
            search_text_extraction_direction: "bidirectional",
            autogenerate_shard_id: 'true',
            autogenerate_shard_id_range: 16
          },
          params: {},
          request: request
        }
      end

      it 'generates a shard id within the specified range' do
        shard_ids = []
        32.times do
          shard_ids.push(subject.shard_id)
        end

        expect(shard_ids).to all( be <= 16 )
      end
    end

    context "json" do
      context "extracted from message" do
        let(:settings) do
          {
            extract_shard_enabled: true,
            extract_shard_content_type: 'json',
            extract_shard_path: "body.href",
          }
        end

        context "regular body" do
          let(:body) do
            <<-JSON
              {
                "href": "https://somejson.com/ac26e190-b41d-11e7-9156-899921d2812c",
                "eventType": "EVENT.TYPE",
                "body": {
                  "href": "https://somejson.com/3c45fd01-a58d-44ca-904c-e0a525598a36",
                  "status": "STATUS"
                }
              }
            JSON
          end

          it "returns shard from header" do
            expect(subject.shard_id).to eq "https://somejson.com/3c45fd01-a58d-44ca-904c-e0a525598a36"
          end
        end

        context "irregular body" do
          let(:body) do
            <<-JSON
              {
                "href": "https://somejson.com/ac26e190-b41d-11e7-9156-899921d2812c",
                "eventType": "EVENT.TYPE",
                "body": {
                  "href": "#{'1234567890' * 19}z",
                  "status": "STATUS"
                }
              }
            JSON
          end

          it "only uses the last 190 characters of the extracted shard" do
            expect(subject.shard_id.to_s.size).to eq 190
            expect(subject.shard_id.to_s[0]).to eq "2"
            expect(subject.shard_id.to_s[-1]).to eq "z"
          end
        end

        context "path does not exist" do
          context "end of path does not exist" do
            let(:body) do
              <<-JSON
                {
                  "href": "https://somejson.com/ac26e190-b41d-11e7-9156-899921d2812c",
                  "eventType": "EVENT.TYPE",
                  "body": {
                  }
                }
              JSON
            end

            it "returns an empty string" do
              expect(subject.shard_id).to eq ""
            end
          end

          context "start of path does not exist" do
            let(:body) do
              <<-JSON
                {
                }
              JSON
            end

            it "returns an empty string" do
              expect(subject.shard_id).to eq ""
            end
          end
        end

        context "no content type configured" do
          let(:settings) do
            {
              extract_shard_enabled: true,
              extract_shard_path: "body.href",
            }
          end

          it "returns nil" do
            expect(subject.shard_id).to be nil
          end
        end
      end
    end

    context "xml" do
      context "extracted from message" do
        let(:settings) do
          {
            extract_shard_enabled: true,
            extract_shard_content_type: 'xml',
            extract_shard_path: "/MainBody/mainInfo/nestedMainInfo/someIds/theIdWeWant",
          }
        end

        let(:message_shard_value) { rand(9999999999).to_s }

        let(:body) do
          <<-XML
            <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
            <MainBody>
                <someMainBodyElement>Some Element</someMainBodyElement>
                <someData>
                    <someSubDataOne>Data</someSubDataOne>
                    <someSubDataTwo>DataData</someSubDataTwo>
                    <someSubDataThree>DataDataData</someSubDataThree>
                </someData>
                <mainInfo>
                    <nestedMainInfo>
                        <someMainInfoElement>Another Element</someMainInfoElement>
                        <someIds>
                            <someIdWeDontWant>NotThisOne</someIdWeDontWant>
                            <theIdWeWant>#{message_shard_value}</theIdWeWant>
                        </someIds>
                    </nestedMainInfo>
                </mainInfo>
            </MainBody>
          XML
        end

        context "regular body" do
          it "returns shard from header" do
            expect(subject.shard_id).to eq message_shard_value
          end
        end

        context "with namespace" do
          let(:body) do
            <<-XML
              <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
              <ns2:MainBody xmlns:ns2="http://services.google.com/" xmlns:ns3="http://services.google.com/">
                  <ns2:someMainBodyElement>Some Element</ns2:someMainBodyElement>
                  <ns2:someData>
                      <ns3:someSubDataOne>Data</ns3:someSubDataOne>
                      <ns3:someSubDataTwo>DataData</ns3:someSubDataTwo>
                      <ns3:someSubDataThree>DataDataData</ns3:someSubDataThree>
                  </ns2:someData>
                  <ns2:mainInfo>
                      <ns2:nestedMainInfo>
                          <ns2:someMainInfoElement>Another Element</ns2:someMainInfoElement>
                          <ns2:someIds>
                              <ns2:someIdWeDontWant>NotThisOne</ns2:someIdWeDontWant>
                              <ns2:theIdWeWant>#{message_shard_value}</ns2:theIdWeWant>
                          </ns2:someIds>
                      </ns2:nestedMainInfo>
                  </ns2:mainInfo>
              </ns2:MainBody>
            XML
          end

          it "returns shard from header" do
            expect(subject.shard_id).to eq message_shard_value
          end
        end

        context "long shard id" do
          let(:message_shard_value) { "12" + ("A" * 188) + "z" }
          it "only uses the last 190 characters of the extracted shard" do
            expect(subject.shard_id.to_s.size).to eq 190
            expect(subject.shard_id.to_s[0]).to eq "2"
            expect(subject.shard_id.to_s[-1]).to eq "z"
          end
        end

        context "special character in xml" do
          let(:message_shard_value) {"d√©cor"}
          it "returns the special character shard value" do
            expect(subject.shard_id).to eq message_shard_value
          end
        end

        context "invalid xml" do
          context "still has the starting tag for the shard" do
            let(:body) do
            <<-XML
              <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
              <MainBody>
                  <someMainBodyElement>Some Element</someMainBodyElement>
                  <someData>
                      <someSubDataOne>Data</someSubDataOne>
                      <someSubDataTwo>DataData</someSubDataTwo>
                      <someSubDataThree>DataDataData</someSubDataThree>
                  </someData>
                  laksjdfhlaksdjhflaksjdhflkajshdfaklsdhf
                  >><><><<>><<><><>><><><><>><><>
                  <mainInfo>
                      <nestedMainInfo>
                          <someMainInfoElement>Another Element</someMainInfoElement>
                          <someIds>
                              <someIdWeDontWant>NotThisOne</someIdWeDontWant>
                              <theIdWeWant>#{message_shard_value}</whatisthistag>
                          </someIds>
                      </notAnEndingTag>
            XML
            end

            it "returns the shard" do
              expect(subject.shard_id).to eq message_shard_value
            end
          end

          context "does not have the starting node" do
            let(:body) do
            <<-XML
              <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
              <MainBody>
                  <someMainBodyElement>Some Element</someMainBodyElement>
                  <someData>
                      <someSubDataOne>Data</someSubDataOne>
                      <someSubDataTwo>DataData</someSubDataTwo>
                      <someSubDataThree>DataDataData</someSubDataThree>
                  </someData>
                  laksjdfhlaksdjhflaksjdhflkajshdfaklsdhf
                  >><><><<>><<><><>><><><><>><><>
                  <mainInfo>
                      <nestedMainInfo>
                          <someMainInfoElement>Another Element</someMainInfoElement>
                          <someIds>
                              <someIdWeDontWant>NotThisOne</someIdWeDontWant>
                              <whatisthistag>#{message_shard_value}</theIdWeWant>
                          </someIds>
                      </notAnEndingTag>
            XML
            end

            it "returns the shard" do
              expect(subject.shard_id).to eq ""
            end
          end
        end

        context "path does not exist" do
          context "end of path does not exist" do
            let(:body) do
              <<-XML
                <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
                <ns2:MainBody xmlns:ns2="http://services.google.com/" xmlns:ns3="http://services.google.com/">
                    <ns2:someMainBodyElement>Some Element</ns2:someMainBodyElement>
                    <ns2:someData>
                        <ns3:someSubDataOne>Data</ns3:someSubDataOne>
                        <ns3:someSubDataTwo>DataData</ns3:someSubDataTwo>
                        <ns3:someSubDataThree>DataDataData</ns3:someSubDataThree>
                    </ns2:someData>
                    <ns2:mainInfo>
                    </ns2:mainInfo>
                </ns2:MainBody>
              XML
            end

            it "returns an empty string" do
              expect(subject.shard_id).to eq ""
            end
          end

          context "start of path does not exist" do
            let(:body) do
              <<-XML
                <event></event>
              XML
            end

            it "returns an empty string" do
              expect(subject.shard_id).to eq ""
            end
          end
        end

        context "no content type configured" do
          let(:settings) do
            {
              extract_shard_enabled: true,
              extract_shard_path: "/body/href",
            }
          end

          it "returns nil" do
            expect(subject.shard_id).to be nil
          end
        end
      end
    end
  end
end
